# 面试题

## ES6相关面试题

#### var let const 相关

````
// var let const
// 1. 声明提升 => 先上车后买票
console.log(num)	// undefined	let定义会错误
var num = 123

// 2. 变量覆盖 => 套牌车
var num1 = 12
var num2 = 34
console.log(num1)	// 34	let定义会错误

// 3. var没有块级作用域 => 出轨
function fn2() {
    for(var i = 0; i < 3; i++) {
        console.log(i)	// 0 1 2
    }
    console.log(i)  //  3		let定义会错误
}
fn2()

// 1. const声明之后必须赋值，否则就报错
// 2. 定义的值不能修改，否则报错
// 3. 支持let的其它属性
const demo = 123
demo = 456	
console.log(const)	

// 解构相关
let a = 1
let b = 2
[a, b] = [b, a]

// ES6去重
let arr = [12, 43, 23, 12, 43, 55]
let item = [...new Set(arr)]

// Promise原理 => 构造函数同步执行
const promise = new Promise((resolve, reject) => {
    console.log(1)
    resolve()
    console.log(2)
})
// .then()异步执行
promise.then(() => {
    console.log(3)
})
console.log(4)
````

#### 原型与原型链

````
// 原型 prototype => 函数特有
// 原型链 __proto__ => [[prototype]]
let obj = {}
let arr = []
// 常规的对象和数组都没有原型
function fn() {}
fn.prototype.name = 'xeon'
fn.prototype.fn2 = function() {
	console.log('name')
}

function Person() {}
Person.prototype.name = 'xeon'
Person.prototype.age = 18
Person.prototype.getAge = function() {
	console.log(this.age)
}
// 实例
let person1 = new Person()
person1.age = 28
person1.name = "lei"
// console.log(person1)
person1.getAge()   // 28

// 找自身的私有属性
let item 
for(item in person1) {
	if(person1.hasOwnProperty(item)){
		console.log(item)
	}
}

// 从当前实例属性去查找，如果找到了就返回，否则顺着原型链一层一层往上面查找
// 直到找到 null 为止，如果找到 null 都没有找到，报错
````

#### 过滤filter



## js 面试题

#### null 与 undefined

````
console.log(typeof null)    // Object  表示为"无"对象 0
console.log(typeof undefined)   // undefined  表示"无"的原始值 NaN

// undefined      
// 1. 已声明，未赋值
let a
console.log(a);

// 2. 对象某个属性不存在
let obj = {}
console.log(obj.a);

// 3. 函数调用，少了参数
function fn(a, b){
	console.log(a, b)
}
fn(1)

// 4. 函数的默认返回值
function abcd() {
	console.log("11")
}
console.log(abcd());

//null
// 1. 手动释放内存
// 2. 作为函数的参数（此参数不是对象）
// 3. 原型链的顶端
let obj = {}
obj = null
````

#### forEach() 与 map()

````
// forEach
// 1. 没有返回值
// 2. 不能用 break 打断
// 3. 遍历的是 value
let arr = ['a', 'b', 'c']
let res = arr.forEach(element => {
	console.log(element);
	// break;
	return element + '1'
})
console.log(res);

// map
// 1. 有返回值（数组）默认 return 是 undefined
// 2. 接受的参数是一个函数（value, key）
// 3. 不能用 break 打断
let arr = ['a', 'b', 'c']
let res = arr.map((value, key) => {
	return value + '1'
})
console.log(res);
````



#### js 递归求和 1 - 100

````
// 1 + 2 + 3 + ...
function add(num1, num2) {
  let num = num1 + num2			// num 前两个数相加，1 + 2 开始
  	if (num2 + 1 > 100) {		// num2大于100退出函数返回求和值
    	return num
    } else {
    	return add(num, ++num2)	// num2不大于100时，回调 add()继续相加num(前两个数的总和),num2++
  }
}
let sum = add(1, 2)
console.log(sum)  // 5050
````



#### JS 防抖与节流

````
// 防抖 => 固定的时间内，事件只允许发生一次
<input type="text" placeholder="输入用户名">

let telInput = document.querySelector('input')
telInput.addEventListener('input', antiShake(demo, 2000))

// 防抖封装
function antiShake(fn, wait){
	let timeOut = null
	return args => {
    if(timeOut) clearTimeout(timeOut)
        timeOut = setTimeout(fn, wait)
    }
}
function demo() {
	console.log('发起请求');
}
````

````

// 节流 => 一定时间内的多个事件合为一个
// 应用场景 => 1. 提交表单  2. 高频监听事件
let box = document.querySelector(".box")
box.addEventListener("touchmove", throttle(demo, 2000))

// 节流封装
function throttle(fn, time) {
	let timer = null
	return args => {
		if (!timer) {
			timer = setTimeout(() => {
				fn()
				timer = null
			}, time)
		}
	}
}

// 还可以通过时间戳
````





























