# 面试题

## ES6相关面试题

#### var let const 相关

````
// var let const
// 1. 声明提升 => 先上车后买票
console.log(num)	// undefined	let定义会错误
var num = 123

// 2. 变量覆盖 => 套牌车
var num1 = 12
var num2 = 34
console.log(num1)	// 34	let定义会错误

// 3. var没有块级作用域 => 出轨
function fn2() {
    for(var i = 0; i < 3; i++) {
        console.log(i)	// 0 1 2
    }
    console.log(i)  //  3		let定义会错误
}
fn2()

// 1. const声明之后必须赋值，否则就报错
// 2. 定义的值不能修改，否则报错
// 3. 支持let的其它属性
const demo = 123
demo = 456	
console.log(const)	

// 解构相关
let a = 1
let b = 2
[a, b] = [b, a]

// ES6去重
let arr = [12, 43, 23, 12, 43, 55]
let item = [...new Set(arr)]

// Promise原理 => 构造函数同步执行
const promise = new Promise((resolve, reject) => {
    console.log(1)
    resolve()
    console.log(2)
})
// .then()异步执行
promise.then(() => {
    console.log(3)
})
console.log(4)
````

#### 原型与原型链

````
// 原型 prototype => 函数特有
// 原型链 __proto__ => [[prototype]]
let obj = {}
let arr = []
// 常规的对象和数组都没有原型
function fn() {}
fn.prototype.name = 'xeon'
fn.prototype.fn2 = function() {
	console.log('name')
}

function Person() {}
Person.prototype.name = 'xeon'
Person.prototype.age = 18
Person.prototype.getAge = function() {
	console.log(this.age)
}
// 实例
let person1 = new Person()
person1.age = 28
person1.name = "lei"
// console.log(person1)
person1.getAge()   // 28

// 找自身的私有属性
let item 
for(item in person1) {
	if(person1.hasOwnProperty(item)){
		console.log(item)
	}
}

// 从当前实例属性去查找，如果找到了就返回，否则顺着原型链一层一层往上面查找
// 直到找到 null 为止，如果找到 null 都没有找到，报错
````

#### 过滤filter



## js 面试题

#### 延迟加载 JS 有哪些方式

````
延迟加载：async，defer
   例如：<script defer type="text/javascript" src="script.js"></script>	// 外部引用

defer：等 html 全部解析完成，才会执行 js 代码，顺次执行 js 脚本。
async：async 是和 html 解析同步的（一起的），不是顺次执行 js 脚本（谁先加载完谁先执行）
````

#### JS 数据类型有哪些

````
基本类型：string、number、boolean、undefined、null、symbol、bigint
引用类型：object
````

面试题

````
// boolean 类型与数值类型相加，先转成数值类型
console.log(true + 1)		// 2
// 字符串和其它类型相加，变成连接的开式，新的字符串
console.log('name' + true)	// 'nametrue'
// undefined 是 数值类型
console.log( undefined + 1)		// NaN
// NaN 是一个数值类型，但是 不是一个具体的数字
````

#### null 与 undefined

````
console.log(typeof null)    // Object  表示为"无"对象 0
console.log(typeof undefined)   // undefined  表示"无"的原始值 NaN

// undefined      
// 1. 已声明，未赋值
let a
console.log(a);

// 2. 对象某个属性不存在
let obj = {}
console.log(obj.a);

// 3. 函数调用，少了参数
function fn(a, b){
	console.log(a, b)
}
fn(1)

// 4. 函数的默认返回值
function abcd() {
	console.log("11")
}
console.log(abcd());

//null
// 1. 手动释放内存
// 2. 作为函数的参数（此参数不是对象）
// 3. 原型链的顶端
let obj = {}
obj = null
````

#### == 和 === 有什么不同

````
== : 比较的是值
		string == number || boolean || number ...都会隐式转换
		通过 valueOf 转换（valueOf() 方法通常由 JavaScript 在后台自动转换）
=== ：比较值，还比较类型
````

#### JS 微任务和宏任务

````
1. js是单线程的语言
2. js代码执行流程：同步执行完 ==> 事件循环
   同步的任务都执行完了，才会执行事件循环的内容
   进入事件循环：请求，定时器，事件...
3. 事件循环中包含：[微任务，宏任务]
微任务：promise.then
宏任务：setTimeout..

要执行宏任务的前提是清空了所有的微任务

流程：同步 ==> 事件循环 [微任务和宏任务] ==> 微任务 ==> 宏任务 ==> 微任务...

````

````
setTimeout(() => {
	console.log('宏任务1')
})
new Promise((resolve) => {
	console.log('同步任务1')
	resolve()
}).then(() => {
	console.log('微任务1');
}).then(() => {
	console.log('微任务1');
})
console.log('同步任务2');

// 打印结果
同步任务1
同步任务2
微任务1
微任务1
宏任务1
````





#### forEach() 与 map()

````
// forEach
// 1. 没有返回值
// 2. 不能用 break 打断
// 3. 遍历的是 value
let arr = ['a', 'b', 'c']
let res = arr.forEach(element => {
	console.log(element);
	// break;
	return element + '1'
})
console.log(res);

// map
// 1. 有返回值（数组）默认 return 是 undefined
// 2. 接受的参数是一个函数（value, key）
// 3. 不能用 break 打断√√
let arr = ['a', 'b', 'c']
let res = arr.map((value, key) => {
	return value + '1'
})
console.log(res);ΩΩΩΩΩΩ≈ç√∫µ≤≤≥ç√√≤≤≥ç√√≤≤≥ç√√
````



#### js 递归求和 1 - 100

````
// 1 + 2 + 3 + ...
function add(num1, num2) {
  let num = num1 + num2			// num 前两个数相加，1 + 2 开始
  	if (num2 + 1 > 100) {		// num2大于100退出函数返回求和值
    	return num
    } else {
    	return add(num, ++num2)	// num2不大于100时，回调 add()继续相加num(前两个数的总和),num2++
  }
}
let sum = add(1, 2)
console.log(sum)  // 5050
````



#### JS 防抖与节流

````
// 防抖 => 固定的时间内，事件只允许发生一次
<input type="text" placeholder="输入用户名">

let telInput = document.querySelector('input')
telInput.addEventListener('input', antiShake(demo, 2000))

// 防抖封装
function antiShake(fn, wait){
	let timeOut = null
	return args => {
    if(timeOut) clearTimeout(timeOut)
        timeOut = setTimeout(fn, wait)
    }
}
function demo() {
	console.log('发起请求');
}
````

````

// 节流 => 一定时间内的多个事件合为一个
// 应用场景 => 1. 提交表单  2. 高频监听事件
let box = document.querySelector(".box")
box.addEventListener("touchmove", throttle(demo, 2000))

// 节流封装
function throttle(fn, time) {
	let timer = null
	return args => {
		if (!timer) {
			timer = setTimeout(() => {
				fn()
				timer = null
			}, time)
		}
	}
}

// 还可以通过时间戳
````





























