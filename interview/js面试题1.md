1、js 的数据类型有哪些，值是如何存储

基本数据类型，Number	String	Boolean	null 	undefined	Symbol	Bigint

引用数据类型，Object

基本数据类型，基本存储在栈（stack）中，占据空间小，大小固定，属于被频繁使用数据，所以放入栈中存储

引用数据类型，同时存储在栈（stack）和堆（heap）中，占据空间大，大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中实体的起始地址。

2、js 的数据类型的转换有那些

三种，分别是：

转换为布尔值（调用 Boolean()方法）
转换为数字（调用 Number()、parseInt()和 parseFloat()方法）
转换为字符串（调用.toString()或者 String()方法）

注：null 和 undefined 没有 .toString 方法

3、如何去判断 js 数据类型

typeof 只能判断基本数据类型，对于引用数据类型，一律返回 object。
在 js 中，数组是一种特殊的对象类型，因此 typeof 判断数组，返回的是 object

instanceof来判断，它不能检测基本数据类型，它是用来判断一个实例是否属于某种类型，使用它的方式可以用
A instanceof B ，如果 A 是 B 的实例，则返回 true，否则返回 false

constructor 来判断，除了 undefined 和 null 之外，其它类型都可以通过 constructor 来判断，但是如果声明了一个构造函数，并且把它的原型指向改变了，这种情况下，constructor 也不能准确的判断

Object.prototype.toString，判断一个对象只属于某种内置类型，但是不能准确的判断一个实例是否属于某种类型。
原因是因为实例对象可能会自定义 toString 方法，把这个方法给覆盖掉，我们可以通过函数 .call()方法，可以在任意值上调用这个方法，帮助我们判断这个值的类型。

4、介绍 js 有哪些内置对象

全局变量值 NaN	undefind
全局函数	parerInt()	parseFloat()
构造函数	Date	Object
还有数学计算的单体内置对象 Math 对象

5、javascript 创建对象的几种方式

（1）工厂模式
（2）构造函数	new()
（3）原型模式	prototype
（4）构造函数和原型模式组合
（5）动态原型模式
（6）寄生框选函数模式

6、js 获取原型的方法

````
p.proto
p.coustructor.prototype
Object.getPrototypeOf
````

7、什么是闭包，为什么要用它

说白了就是函数嵌套函数，内部函数能够访问外部函数的变量，且在外部被执行，就产生了闭包

（1）创建私有变量，避免全局变量的污染
（2）可以使已经运行结束的函数中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收

9、哪些操作会造成内存泄漏

（1）意外的全局变量：第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收
（2）被遗忘的计时器或回调函数：设置了 setInterval 定时器，而忘记取消它
（3）脱离 DOM 的引用：获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收
（4）闭包：不合理的使用闭包，从而导致某些变量一直被留在内存当中

10、javascript 中 this 的指向

（1）普通函数调用
这个情况没特殊意外，就是指向全局对象 windows

（2）对象函数调用
这个相信不难理解，就是哪个函数调用，this 指向哪里

（3）构造函数调用
构造函数返回对象的 this

> 在构造函数里面返回一个对象，会直接返回这个对象，而不是执行构造函数后创建的对象

（4）apply 和 call 调用
apply 和 call 简单来说就是会改变传入函数的 this。

（5）箭头函数调用
箭头函数里面，没有 `this` ，箭头函数里面的 `this` 是继承外面的环境。

11、解释一下原型链

每一函数有一个 prototype 的属性，当他作为构造函数的时候，它实例化出来的函数会有一个`_proto_`的属性，当访问一个对象的某个属性或者方法的时候，会现在这个对象自身查找，如果没有找到，则会去它的`_proto_`隐式原型上查找，也就是它构造函数的 prototype，如果还没有找到就会再在构造函数的 prototype 的`_proto_`中查找，如果找到著返回 undefined，这个链式查找的过程，我们称为原型链。



